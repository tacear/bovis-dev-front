(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@azure/msal-browser'), require('rxjs'), require('@angular/router'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@azure/msal-angular', ['exports', '@angular/core', '@angular/common', '@azure/msal-browser', 'rxjs', '@angular/router', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.azure = global.azure || {}, global.azure['msal-angular'] = {}), global.ng.core, global.ng.common, global['@azure/msal-browser'], global.rxjs, global.ng.router, global.rxjs.operators));
}(this, (function (exports, core, common, msalBrowser, rxjs, router, operators) { 'use strict';

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MSAL_INSTANCE = new core.InjectionToken("MSAL_INSTANCE");
    var MSAL_GUARD_CONFIG = new core.InjectionToken("MSAL_GUARD_CONFIG");
    var MSAL_INTERCEPTOR_CONFIG = new core.InjectionToken("MSAL_INTERCEPTOR_CONFIG");
    var MSAL_BROADCAST_CONFIG = new core.InjectionToken("MSAL_BROADCAST_CONFIG");

    /* eslint-disable header/header */
    var name = "@azure/msal-angular";
    var version = "2.5.12";

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalService = /** @class */ (function () {
        function MsalService(instance, location) {
            this.instance = instance;
            this.location = location;
            var hash = this.location.path(true).split("#").pop();
            if (hash) {
                this.redirectHash = "#" + hash;
            }
            this.instance.initializeWrapperLibrary(msalBrowser.WrapperSKU.Angular, version);
        }
        MsalService.prototype.initialize = function () {
            return rxjs.from(this.instance.initialize());
        };
        MsalService.prototype.acquireTokenPopup = function (request) {
            return rxjs.from(this.instance.acquireTokenPopup(request));
        };
        MsalService.prototype.acquireTokenRedirect = function (request) {
            return rxjs.from(this.instance.acquireTokenRedirect(request));
        };
        MsalService.prototype.acquireTokenSilent = function (silentRequest) {
            return rxjs.from(this.instance.acquireTokenSilent(silentRequest));
        };
        MsalService.prototype.handleRedirectObservable = function (hash) {
            return rxjs.from(this.instance.handleRedirectPromise(hash || this.redirectHash));
        };
        MsalService.prototype.loginPopup = function (request) {
            return rxjs.from(this.instance.loginPopup(request));
        };
        MsalService.prototype.loginRedirect = function (request) {
            return rxjs.from(this.instance.loginRedirect(request));
        };
        MsalService.prototype.logout = function (logoutRequest) {
            return rxjs.from(this.instance.logout(logoutRequest));
        };
        MsalService.prototype.logoutRedirect = function (logoutRequest) {
            return rxjs.from(this.instance.logoutRedirect(logoutRequest));
        };
        MsalService.prototype.logoutPopup = function (logoutRequest) {
            return rxjs.from(this.instance.logoutPopup(logoutRequest));
        };
        MsalService.prototype.ssoSilent = function (request) {
            return rxjs.from(this.instance.ssoSilent(request));
        };
        /**
         * Gets logger for msal-angular.
         * If no logger set, returns logger instance created with same options as msal-browser
         */
        MsalService.prototype.getLogger = function () {
            if (!this.logger) {
                this.logger = this.instance.getLogger().clone(name, version);
            }
            return this.logger;
        };
        // Create a logger instance for msal-angular with the same options as msal-browser
        MsalService.prototype.setLogger = function (logger) {
            this.logger = logger.clone(name, version);
            this.instance.setLogger(logger);
        };
        return MsalService;
    }());
    MsalService.decorators = [
        { type: core.Injectable }
    ];
    MsalService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_INSTANCE,] }] },
        { type: common.Location }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalBroadcastService = /** @class */ (function () {
        function MsalBroadcastService(msalInstance, authService, msalBroadcastConfig) {
            var _this = this;
            this.msalInstance = msalInstance;
            this.authService = authService;
            this.msalBroadcastConfig = msalBroadcastConfig;
            // Make _msalSubject a ReplaySubject if configured to replay past events
            if (this.msalBroadcastConfig && this.msalBroadcastConfig.eventsToReplay > 0) {
                this.authService.getLogger().verbose("BroadcastService - replayPastEvents set on BroadcastConfig, replaying the last " + this.msalBroadcastConfig.eventsToReplay + " events");
                this._msalSubject = new rxjs.ReplaySubject(this.msalBroadcastConfig.eventsToReplay);
            }
            else {
                // Defaults to _msalSubject being a Subject
                this._msalSubject = new rxjs.Subject();
            }
            this.msalSubject$ = this._msalSubject.asObservable();
            // InProgress as BehaviorSubject so most recent inProgress state will be available upon subscription
            this._inProgress = new rxjs.BehaviorSubject(msalBrowser.InteractionStatus.Startup);
            this.inProgress$ = this._inProgress.asObservable();
            this.msalInstance.addEventCallback(function (message) {
                _this._msalSubject.next(message);
                var status = msalBrowser.EventMessageUtils.getInteractionStatusFromEvent(message, _this._inProgress.value);
                if (status !== null) {
                    _this.authService.getLogger().verbose("BroadcastService - " + message.eventType + " results in setting inProgress from " + _this._inProgress.value + " to " + status);
                    _this._inProgress.next(status);
                }
            });
        }
        return MsalBroadcastService;
    }());
    MsalBroadcastService.decorators = [
        { type: core.Injectable }
    ];
    MsalBroadcastService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_INSTANCE,] }] },
        { type: MsalService },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MSAL_BROADCAST_CONFIG,] }] }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalGuard = /** @class */ (function () {
        function MsalGuard(msalGuardConfig, msalBroadcastService, authService, location, router) {
            this.msalGuardConfig = msalGuardConfig;
            this.msalBroadcastService = msalBroadcastService;
            this.authService = authService;
            this.location = location;
            this.router = router;
            // Subscribing so events in MsalGuard will set inProgress$ observable
            this.msalBroadcastService.inProgress$.subscribe();
        }
        /**
         * Parses url string to UrlTree
         * @param url
         */
        MsalGuard.prototype.parseUrl = function (url) {
            return this.router.parseUrl(url);
        };
        /**
         * Builds the absolute url for the destination page
         * @param path Relative path of requested page
         * @returns Full destination url
         */
        MsalGuard.prototype.getDestinationUrl = function (path) {
            this.authService.getLogger().verbose("Guard - getting destination url");
            // Absolute base url for the application (default to origin if base element not present)
            var baseElements = document.getElementsByTagName("base");
            var baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin);
            // Path of page (including hash, if using hash routing)
            var pathUrl = this.location.prepareExternalUrl(path);
            // Hash location strategy
            if (pathUrl.startsWith("#")) {
                this.authService.getLogger().verbose("Guard - destination by hash routing");
                return baseUrl + "/" + pathUrl;
            }
            /*
             * If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).
             * Since baseUrl also includes /base, can just concatentate baseUrl + path
             */
            return "" + baseUrl + path;
        };
        /**
         * Interactively prompt the user to login
         * @param url Path of the requested page
         */
        MsalGuard.prototype.loginInteractively = function (state) {
            var _this = this;
            var authRequest = typeof this.msalGuardConfig.authRequest === "function"
                ? this.msalGuardConfig.authRequest(this.authService, state)
                : Object.assign({}, this.msalGuardConfig.authRequest);
            if (this.msalGuardConfig.interactionType === msalBrowser.InteractionType.Popup) {
                this.authService.getLogger().verbose("Guard - logging in by popup");
                return this.authService.loginPopup(authRequest)
                    .pipe(operators.map(function (response) {
                    _this.authService.getLogger().verbose("Guard - login by popup successful, can activate, setting active account");
                    _this.authService.instance.setActiveAccount(response.account);
                    return true;
                }));
            }
            this.authService.getLogger().verbose("Guard - logging in by redirect");
            var redirectStartPage = this.getDestinationUrl(state.url);
            return this.authService.loginRedirect(Object.assign({ redirectStartPage: redirectStartPage }, authRequest))
                .pipe(operators.map(function () { return false; }));
        };
        /**
         * Helper which checks for the correct interaction type, prevents page with Guard to be set as reidrect, and calls handleRedirectObservable
         * @param state
         */
        MsalGuard.prototype.activateHelper = function (state) {
            var _this = this;
            if (this.msalGuardConfig.interactionType !== msalBrowser.InteractionType.Popup && this.msalGuardConfig.interactionType !== msalBrowser.InteractionType.Redirect) {
                throw new msalBrowser.BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Guard. InteractionType.Popup or InteractionType.Redirect must be provided in the MsalGuardConfiguration");
            }
            this.authService.getLogger().verbose("MSAL Guard activated");
            /*
             * If a page with MSAL Guard is set as the redirect for acquireTokenSilent,
             * short-circuit to prevent redirecting or popups.
             */
            if (typeof window !== "undefined") {
                if (msalBrowser.UrlString.hashContainsKnownProperties(window.location.hash) && msalBrowser.BrowserUtils.isInIframe() && !this.authService.instance.getConfiguration().system.allowRedirectInIframe) {
                    this.authService.getLogger().warning("Guard - redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.");
                    return rxjs.of(false);
                }
            }
            else {
                this.authService.getLogger().info("Guard - window is undefined, MSAL does not support server-side token acquisition");
                return rxjs.of(true);
            }
            /**
             * If a loginFailedRoute is set in the config, set this as the loginFailedRoute
             */
            if (this.msalGuardConfig.loginFailedRoute) {
                this.loginFailedRoute = this.parseUrl(this.msalGuardConfig.loginFailedRoute);
            }
            // Capture current path before it gets changed by handleRedirectObservable
            var currentPath = this.location.path(true);
            return this.authService.handleRedirectObservable()
                .pipe(operators.concatMap(function () {
                if (!_this.authService.instance.getAllAccounts().length) {
                    if (state) {
                        _this.authService.getLogger().verbose("Guard - no accounts retrieved, log in required to activate");
                        return _this.loginInteractively(state);
                    }
                    _this.authService.getLogger().verbose("Guard - no accounts retrieved, no state, cannot load");
                    return rxjs.of(false);
                }
                _this.authService.getLogger().verbose("Guard - at least 1 account exists, can activate or load");
                // Prevent navigating the app to /#code= or /code=
                if (state) {
                    /*
                     * Path routing:
                     * state.url: /#code=...
                     * state.root.fragment: code=...
                     */
                    /*
                     * Hash routing:
                     * state.url: /code
                     * state.root.fragment: null
                     */
                    var urlContainsCode = _this.includesCode(state.url);
                    var fragmentContainsCode = !!state.root && !!state.root.fragment && _this.includesCode("#" + state.root.fragment);
                    var hashRouting = _this.location.prepareExternalUrl(state.url).indexOf("#") === 0;
                    // Ensure code parameter is in fragment (and not in query parameter), or that hash hash routing is used
                    if (urlContainsCode && (fragmentContainsCode || hashRouting)) {
                        _this.authService.getLogger().info("Guard - Hash contains known code response, stopping navigation.");
                        // Path routing (navigate to current path without hash)
                        if (currentPath.indexOf("#") > -1) {
                            return rxjs.of(_this.parseUrl(_this.location.path()));
                        }
                        // Hash routing (navigate to root path)
                        return rxjs.of(_this.parseUrl(""));
                    }
                }
                return rxjs.of(true);
            }), operators.catchError(function (error) {
                _this.authService.getLogger().error("Guard - error while logging in, unable to activate");
                _this.authService.getLogger().errorPii("Guard - error: " + error.message);
                /**
                 * If a loginFailedRoute is set, checks to see if Angular 10+ is used and state is passed in before returning route
                 * Apps using Angular 9 will receive of(false) in canLoad interface, as it does not support UrlTree return types
                 */
                if (_this.loginFailedRoute && parseInt(core.VERSION.major, 10) > 9 && state) {
                    _this.authService.getLogger().verbose("Guard - loginFailedRoute set, redirecting");
                    return rxjs.of(_this.loginFailedRoute);
                }
                return rxjs.of(false);
            }));
        };
        MsalGuard.prototype.includesCode = function (path) {
            return (path.lastIndexOf("/code") > -1 &&
                path.lastIndexOf("/code") === path.length - "/code".length) || // path.endsWith("/code")
                path.indexOf("#code=") > -1 ||
                path.indexOf("&code=") > -1;
        };
        MsalGuard.prototype.canActivate = function (route, state) {
            this.authService.getLogger().verbose("Guard - canActivate");
            return this.activateHelper(state);
        };
        MsalGuard.prototype.canActivateChild = function (route, state) {
            this.authService.getLogger().verbose("Guard - canActivateChild");
            return this.activateHelper(state);
        };
        MsalGuard.prototype.canLoad = function () {
            this.authService.getLogger().verbose("Guard - canLoad");
            // @ts-ignore
            return this.activateHelper();
        };
        return MsalGuard;
    }());
    MsalGuard.decorators = [
        { type: core.Injectable }
    ];
    MsalGuard.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_GUARD_CONFIG,] }] },
        { type: MsalBroadcastService },
        { type: MsalService },
        { type: common.Location },
        { type: router.Router }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalInterceptor = /** @class */ (function () {
        function MsalInterceptor(msalInterceptorConfig, authService, location, msalBroadcastService, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
        document) {
            this.msalInterceptorConfig = msalInterceptorConfig;
            this.authService = authService;
            this.location = location;
            this.msalBroadcastService = msalBroadcastService;
            this._document = document;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        MsalInterceptor.prototype.intercept = function (req, next) {
            var _this = this;
            if (this.msalInterceptorConfig.interactionType !== msalBrowser.InteractionType.Popup && this.msalInterceptorConfig.interactionType !== msalBrowser.InteractionType.Redirect) {
                throw new msalBrowser.BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Interceptor. InteractionType.Popup, InteractionType.Redirect must be provided in the msalInterceptorConfiguration");
            }
            this.authService.getLogger().verbose("MSAL Interceptor activated");
            var scopes = this.getScopesForEndpoint(req.url, req.method);
            // If no scopes for endpoint, does not acquire token
            if (!scopes || scopes.length === 0) {
                this.authService.getLogger().verbose("Interceptor - no scopes for endpoint");
                return next.handle(req);
            }
            // Sets account as active account or first account
            var account;
            if (!!this.authService.instance.getActiveAccount()) {
                this.authService.getLogger().verbose("Interceptor - active account selected");
                account = this.authService.instance.getActiveAccount();
            }
            else {
                this.authService.getLogger().verbose("Interceptor - no active account, fallback to first account");
                account = this.authService.instance.getAllAccounts()[0];
            }
            var authRequest = typeof this.msalInterceptorConfig.authRequest === "function"
                ? this.msalInterceptorConfig.authRequest(this.authService, req, { account: account })
                : Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { account: account });
            this.authService.getLogger().info("Interceptor - " + scopes.length + " scopes found for endpoint");
            this.authService.getLogger().infoPii("Interceptor - [" + scopes + "] scopes found for " + req.url);
            return this.acquireToken(authRequest, scopes, account)
                .pipe(operators.switchMap(function (result) {
                _this.authService.getLogger().verbose("Interceptor - setting authorization headers");
                var headers = req.headers
                    .set("Authorization", "Bearer " + result.accessToken);
                var requestClone = req.clone({ headers: headers });
                return next.handle(requestClone);
            }));
        };
        /**
         * Try to acquire token silently. Invoke interaction if acquireTokenSilent rejected with error or resolved with null access token
         * @param authRequest Request
         * @param scopes Array of scopes for the request
         * @param account Account
         * @returns Authentication result
         */
        MsalInterceptor.prototype.acquireToken = function (authRequest, scopes, account) {
            var _this = this;
            // Note: For MSA accounts, include openid scope when calling acquireTokenSilent to return idToken
            return this.authService.acquireTokenSilent(Object.assign(Object.assign({}, authRequest), { scopes: scopes, account: account }))
                .pipe(operators.catchError(function () {
                _this.authService.getLogger().error("Interceptor - acquireTokenSilent rejected with error. Invoking interaction to resolve.");
                return _this.msalBroadcastService.inProgress$
                    .pipe(operators.take(1), operators.switchMap(function (status) {
                    if (status === msalBrowser.InteractionStatus.None) {
                        return _this.acquireTokenInteractively(authRequest, scopes);
                    }
                    return _this.msalBroadcastService.inProgress$
                        .pipe(operators.filter(function (status) { return status === msalBrowser.InteractionStatus.None; }), operators.take(1), operators.switchMap(function () { return _this.acquireToken(authRequest, scopes, account); }));
                }));
            }), operators.switchMap(function (result) {
                if (!result.accessToken) {
                    _this.authService.getLogger().error("Interceptor - acquireTokenSilent resolved with null access token. Known issue with B2C tenants, invoking interaction to resolve.");
                    return _this.msalBroadcastService.inProgress$
                        .pipe(operators.filter(function (status) { return status === msalBrowser.InteractionStatus.None; }), operators.take(1), operators.switchMap(function () { return _this.acquireTokenInteractively(authRequest, scopes); }));
                }
                return rxjs.of(result);
            }));
        };
        /**
         * Invoke interaction for the given set of scopes
         * @param authRequest Request
         * @param scopes Array of scopes for the request
         * @returns Result from the interactive request
         */
        MsalInterceptor.prototype.acquireTokenInteractively = function (authRequest, scopes) {
            if (this.msalInterceptorConfig.interactionType === msalBrowser.InteractionType.Popup) {
                this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by popup");
                return this.authService.acquireTokenPopup(Object.assign(Object.assign({}, authRequest), { scopes: scopes }));
            }
            this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by redirect");
            var redirectStartPage = window.location.href;
            this.authService.acquireTokenRedirect(Object.assign(Object.assign({}, authRequest), { scopes: scopes, redirectStartPage: redirectStartPage }));
            return rxjs.EMPTY;
        };
        /**
         * Looks up the scopes for the given endpoint from the protectedResourceMap
         * @param endpoint Url of the request
         * @param httpMethod Http method of the request
         * @returns Array of scopes, or null if not found
         *
         */
        MsalInterceptor.prototype.getScopesForEndpoint = function (endpoint, httpMethod) {
            this.authService.getLogger().verbose("Interceptor - getting scopes for endpoint");
            // Ensures endpoints and protected resources compared are normalized
            var normalizedEndpoint = this.location.normalize(endpoint);
            var protectedResourcesArray = Array.from(this.msalInterceptorConfig.protectedResourceMap.keys());
            var matchingProtectedResources = this.matchResourcesToEndpoint(protectedResourcesArray, normalizedEndpoint);
            // Check absolute urls of resources first before checking relative to prevent incorrect matching where multiple resources have similar relative urls
            if (matchingProtectedResources.absoluteResources.length > 0) {
                return this.matchScopesToEndpoint(this.msalInterceptorConfig.protectedResourceMap, matchingProtectedResources.absoluteResources, httpMethod);
            }
            else if (matchingProtectedResources.relativeResources.length > 0) {
                return this.matchScopesToEndpoint(this.msalInterceptorConfig.protectedResourceMap, matchingProtectedResources.relativeResources, httpMethod);
            }
            return null;
        };
        /**
         * Finds resource endpoints that match request endpoint
         * @param protectedResourcesEndpoints
         * @param endpoint
         * @returns
         */
        MsalInterceptor.prototype.matchResourcesToEndpoint = function (protectedResourcesEndpoints, endpoint) {
            var _this = this;
            var matchingResources = { absoluteResources: [], relativeResources: [] };
            protectedResourcesEndpoints.forEach(function (key) {
                // Normalizes and adds resource to matchingResources.absoluteResources if key matches endpoint. StringUtils.matchPattern accounts for wildcards
                var normalizedKey = _this.location.normalize(key);
                if (msalBrowser.StringUtils.matchPattern(normalizedKey, endpoint)) {
                    matchingResources.absoluteResources.push(key);
                }
                // Get url components for relative urls
                var absoluteKey = _this.getAbsoluteUrl(key);
                var keyComponents = new msalBrowser.UrlString(absoluteKey).getUrlComponents();
                var absoluteEndpoint = _this.getAbsoluteUrl(endpoint);
                var endpointComponents = new msalBrowser.UrlString(absoluteEndpoint).getUrlComponents();
                // Normalized key should include query strings if applicable
                var relativeNormalizedKey = keyComponents.QueryString ? keyComponents.AbsolutePath + "?" + keyComponents.QueryString : _this.location.normalize(keyComponents.AbsolutePath);
                // Add resource to matchingResources.relativeResources if same origin, relativeKey matches endpoint, and is not empty
                if (keyComponents.HostNameAndPort === endpointComponents.HostNameAndPort && msalBrowser.StringUtils.matchPattern(relativeNormalizedKey, absoluteEndpoint) && relativeNormalizedKey !== "" && relativeNormalizedKey !== "/*") {
                    matchingResources.relativeResources.push(key);
                }
            });
            return matchingResources;
        };
        /**
         * Transforms relative urls to absolute urls
         * @param url
         * @returns
         */
        MsalInterceptor.prototype.getAbsoluteUrl = function (url) {
            var link = this._document.createElement("a");
            link.href = url;
            return link.href;
        };
        /**
         * Finds scopes from first matching endpoint with HTTP method that matches request
         * @param protectedResourceMap Protected resource map
         * @param endpointArray Array of resources that match request endpoint
         * @param httpMethod Http method of the request
         * @returns
         */
        MsalInterceptor.prototype.matchScopesToEndpoint = function (protectedResourceMap, endpointArray, httpMethod) {
            var allMatchedScopes = [];
            // Check each matched endpoint for matching HttpMethod and scopes
            endpointArray.forEach(function (matchedEndpoint) {
                var scopesForEndpoint = [];
                var methodAndScopesArray = protectedResourceMap.get(matchedEndpoint);
                // Return if resource is unprotected
                if (methodAndScopesArray === null) {
                    allMatchedScopes.push(null);
                    return;
                }
                methodAndScopesArray.forEach(function (entry) {
                    // Entry is either array of scopes or ProtectedResourceScopes object
                    if (typeof entry === "string") {
                        scopesForEndpoint.push(entry);
                    }
                    else {
                        // Ensure methods being compared are normalized
                        var normalizedRequestMethod = httpMethod.toLowerCase();
                        var normalizedResourceMethod = entry.httpMethod.toLowerCase();
                        // Method in protectedResourceMap matches request http method
                        if (normalizedResourceMethod === normalizedRequestMethod) {
                            // Validate if scopes comes null to unprotect the resource in a certain http method
                            if (entry.scopes === null) {
                                allMatchedScopes.push(null);
                            }
                            else {
                                entry.scopes.forEach(function (scope) {
                                    scopesForEndpoint.push(scope);
                                });
                            }
                        }
                    }
                });
                // Only add to all scopes if scopes for endpoint and method is found
                if (scopesForEndpoint.length > 0) {
                    allMatchedScopes.push(scopesForEndpoint);
                }
            });
            if (allMatchedScopes.length > 0) {
                if (allMatchedScopes.length > 1) {
                    this.authService.getLogger().warning("Interceptor - More than 1 matching scopes for endpoint found.");
                }
                // Returns scopes for first matching endpoint
                return allMatchedScopes[0];
            }
            return null;
        };
        return MsalInterceptor;
    }());
    MsalInterceptor.decorators = [
        { type: core.Injectable }
    ];
    MsalInterceptor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_INTERCEPTOR_CONFIG,] }] },
        { type: MsalService },
        { type: common.Location },
        { type: MsalBroadcastService },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalRedirectComponent = /** @class */ (function () {
        function MsalRedirectComponent(authService) {
            this.authService = authService;
        }
        MsalRedirectComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.authService.getLogger().verbose("MsalRedirectComponent activated");
            this.authService.initialize().pipe(operators.concatMap(function () {
                return _this.authService.handleRedirectObservable();
            })).subscribe();
        };
        return MsalRedirectComponent;
    }());
    MsalRedirectComponent.decorators = [
        { type: core.Component, args: [{
                    selector: "app-redirect",
                    template: ""
                },] }
    ];
    MsalRedirectComponent.ctorParameters = function () { return [
        { type: MsalService }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalModule = /** @class */ (function () {
        function MsalModule() {
        }
        MsalModule.forRoot = function (msalInstance, guardConfig, interceptorConfig) {
            return {
                ngModule: MsalModule,
                providers: [
                    {
                        provide: MSAL_INSTANCE,
                        useValue: msalInstance
                    },
                    {
                        provide: MSAL_GUARD_CONFIG,
                        useValue: guardConfig
                    },
                    {
                        provide: MSAL_INTERCEPTOR_CONFIG,
                        useValue: interceptorConfig
                    },
                    MsalService
                ]
            };
        };
        return MsalModule;
    }());
    MsalModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [MsalRedirectComponent],
                    imports: [
                        common.CommonModule
                    ],
                    providers: [
                        MsalGuard,
                        MsalBroadcastService
                    ]
                },] }
    ];

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) { if (f !== void 0 && typeof f !== "function")
            throw new TypeError("Function expected"); return f; }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
            var context = {};
            for (var p in contextIn)
                context[p] = p === "access" ? {} : contextIn[p];
            for (var p in contextIn.access)
                context.access[p] = contextIn.access[p];
            context.addInitializer = function (f) { if (done)
                throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
            var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0)
                    continue;
                if (result === null || typeof result !== "object")
                    throw new TypeError("Object expected");
                if (_ = accept(result.get))
                    descriptor.get = _;
                if (_ = accept(result.set))
                    descriptor.set = _;
                if (_ = accept(result.init))
                    initializers.push(_);
            }
            else if (_ = accept(result)) {
                if (kind === "field")
                    initializers.push(_);
                else
                    descriptor[key] = _;
            }
        }
        if (target)
            Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    }
    ;
    function __runInitializers(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    }
    ;
    function __propKey(x) {
        return typeof x === "symbol" ? x : "".concat(x);
    }
    ;
    function __setFunctionName(f, name, prefix) {
        if (typeof name === "symbol")
            name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    }
    ;
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function () { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }
    function __classPrivateFieldIn(state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function"))
            throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    }

    /**
     * Custom navigation used for Angular client-side navigation.
     * See performance doc for details:
     * https://github.com/AzureAD/microsoft-authentication-library-for-js/tree/dev/lib/msal-angular/docs/v2-docs/performance.md
     */
    var MsalCustomNavigationClient = /** @class */ (function (_super_1) {
        __extends(MsalCustomNavigationClient, _super_1);
        function MsalCustomNavigationClient(authService, router, location) {
            var _this = _super_1.call(this) || this;
            _this.authService = authService;
            _this.router = router;
            _this.location = location;
            return _this;
        }
        MsalCustomNavigationClient.prototype.navigateInternal = function (url, options) {
            var _super = Object.create(null, {
                navigateInternal: { get: function () { return _super_1.prototype.navigateInternal; } }
            });
            return __awaiter(this, void 0, void 0, function () {
                var urlComponents, newUrl;
                return __generator(this, function (_a) {
                    this.authService.getLogger().trace("MsalCustomNavigationClient called");
                    this.authService.getLogger().verbose("MsalCustomNavigationClient - navigating");
                    this.authService.getLogger().verbosePii("MsalCustomNavigationClient - navigating to url: " + url);
                    // Prevent hash clearing from causing an issue with Client-side navigation after redirect is handled
                    if (options.noHistory) {
                        return [2 /*return*/, _super.navigateInternal.call(this, url, options)];
                    }
                    else {
                        urlComponents = new msalBrowser.UrlString(url).getUrlComponents();
                        newUrl = urlComponents.QueryString ? urlComponents.AbsolutePath + "?" + urlComponents.QueryString : this.location.normalize(urlComponents.AbsolutePath);
                        this.router.navigateByUrl(newUrl, { replaceUrl: options.noHistory });
                    }
                    return [2 /*return*/, Promise.resolve(options.noHistory)];
                });
            });
        };
        return MsalCustomNavigationClient;
    }(msalBrowser.NavigationClient));
    MsalCustomNavigationClient.decorators = [
        { type: core.Injectable }
    ];
    MsalCustomNavigationClient.ctorParameters = function () { return [
        { type: MsalService },
        { type: router.Router },
        { type: common.Location }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.MSAL_BROADCAST_CONFIG = MSAL_BROADCAST_CONFIG;
    exports.MSAL_GUARD_CONFIG = MSAL_GUARD_CONFIG;
    exports.MSAL_INSTANCE = MSAL_INSTANCE;
    exports.MSAL_INTERCEPTOR_CONFIG = MSAL_INTERCEPTOR_CONFIG;
    exports.MsalBroadcastService = MsalBroadcastService;
    exports.MsalCustomNavigationClient = MsalCustomNavigationClient;
    exports.MsalGuard = MsalGuard;
    exports.MsalInterceptor = MsalInterceptor;
    exports.MsalModule = MsalModule;
    exports.MsalRedirectComponent = MsalRedirectComponent;
    exports.MsalService = MsalService;
    exports.version = version;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=azure-msal-angular.umd.js.map
